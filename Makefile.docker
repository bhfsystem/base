org := $(shell (cat Blockfile.json 2>/dev/null || echo '{}') | jq -r '.block.org//"imma"')
block := $(shell basename $(shell echo $(PWD)))
image = block:$(block)
version = $(shell git rev-parse --abbrev-ref HEAD)
ifeq (HEAD,$(version))
version = $(shell git rev-parse HEAD)
endif

ifeq (stop,$(firstword $(MAKECMDGOALS)))
STOP := $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS))
$(eval $(STOP):;@:)
endif

ifeq (start,$(firstword $(MAKECMDGOALS)))
START := $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS))
$(eval $(START):;@:)
endif

ifeq (status,$(firstword $(MAKECMDGOALS)))
STATUS := $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS))
$(eval $(STATUS):;@:)
endif

ifeq (ssh,$(firstword $(MAKECMDGOALS)))
SERVICE := $(strip $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS)))
$(eval $(SERVICE):;@:)
endif

ifeq (cat,$(firstword $(MAKECMDGOALS)))
SERVICE := $(strip $(wordlist 2,2,$(MAKECMDGOALS)))
FILE := $(strip $(wordlist 3,3,$(MAKECMDGOALS)))
$(eval $(SERVICE):;@:)
$(eval $(FILE):;@:)
endif

ifeq (rebuild,$(firstword $(MAKECMDGOALS)))
REBUILD := $(strip $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS)))
$(eval $(REBUILD):;@:)
endif
REBUILD ?= app

SERVICE ?= $(block)
ifeq "$(strip $(SERVICE))" ""
SERVICE := $(block)
endif

SHELL = bash

NET_SUBNET ?= 172.28.130
NET_PREFIX ?= 172.28.131

cache_vip ?= 172.28.128.1
ssh_vip ?= 172.28.29.250

ssh_user ?= $(LOGNAME)
ssh_port ?= 2222

ssh_remote_user ?= ubuntu
ssh_remote_home ?= /home/ubuntu

service = $(block)_$(SERVICE)_1
service_ssh_port = $(shell docker inspect $(service) 2>/dev/null | jq -r '.[].NetworkSettings.Ports["$(ssh_port)/tcp"][].HostPort')
service_ssh_exec = $(ssh_prefix) ssh -A -p $(service_ssh_port) $(ssh_remote_user)@$(ssh_vip)

docker_compose ?= env BLOCK_REGISTRY=$(registry) BLOCK_SSH_PORT=$(ssh_port) NET_PREFIX=$(NET_PREFIX) NET_SUBNET=$(NET_SUBNET) docker-compose -f compose.json

env_cache = env http_proxy=$(squid) https_proxy=$(squid)

home = ubuntu

make = $(MAKE) cache=$(cache) squid=$(squid) SERVICE=$(SERVICE)

hub ?= defn
registry ?= docker.nih
cache ?= cache.nih
squid ?= http://$(cache):3128

ifeq (nc,$(firstword $(MAKECMDGOALS)))
cache=
squid=
endif

nothing:
	@true

nc:
	@true

reset-xenial:
	docker pull ubuntu:xenial
	docker tag ubuntu:xenial $(registry)/block:xenial
	docker tag $(registry)/block:xenial $(registry)/$(image)

reset-base:
	docker tag $(registry)/block:base $(registry)/$(image)

reset:
	docker tag $(registry)/block:$(home) $(registry)/$(image)

build:
	if [[ -d .d ]]; then cd .d && docker build --no-cache -t $(registry)/$(image) --build-arg CACHE="$(cache)" --build-arg SERIAL=$(SERIAL) $(opt) .; fi

commit:
	docker commit $(service) $(registry)/$(image) $(opt)

publish:
	docker push $(registry)/$(image)

copy-personal:
	docker cp ~/.ssh/authorized_keys $(service):$(ssh_remote_home)/.ssh/authorized_keys
	docker exec $(service) sudo chown -R $(ssh_remote_user):$(ssh_remote_user) $(ssh_remote_home)/.ssh
	tar cf - -C ~ .gitconfig .ssh/authorized_keys | $(service_ssh_exec) -o StrictHostKeyChecking=no -- tar xvf -

daemon:
	$(make) clean
	$(make) daemon-sshd
	docker cp ~/.ssh/authorized_keys $(service):$(ssh_remote_home)/.ssh/authorized_keys
	docker exec $(service) sudo chown -R $(ssh_remote_user):$(ssh_remote_user) $(ssh_remote_home)/.ssh
	$(make) daemon-ssh

daemon-sshd:
	docker run -d -ti -v /data:/data -v /config:/config --name $(service) -p :$(ssh_port) $(registry)/$(image)

daemon-ssh:
	$(service_ssh_exec) -o StrictHostKeyChecking=no -- true || { sleep 1; $(make) daemon-ssh; }

service-ssh:
	@$(service_ssh_exec) -- true || { sleep 1; $(make) service-ssh; }

compose:
	jq -n --arg registry "$(registry)" --arg block "$(block)" '{version:"2", volumes:{data:{},config:{}}, services:{"\($$block)":{volumes:["data:/data","config:/config"],ports:["$(ssh_port)"],"image":"\($$registry)/block:\($$block)","hostname":"\($$block)"}}}' > compose.json

up:
	env COMPOSE_PROJECT_NAME="$(block)" $(docker_compose) up -d --remove-orphans $(opt)

down:
	env COMPOSE_PROJECT_NAME="$(block)" $(docker_compose) stop $(opt)

destroy:
	env COMPOSE_PROJECT_NAME="$(block)" $(docker_compose) down --remove-orphans $(opt)

shell:
	@$(make) daemon
	@$(make) ssh

ssh:
	@$(ssh_prefix) ssh-keygen -R '[$(ssh_vip)]:$(service_ssh_port)' 2>/dev/null >/dev/null
	$(make) copy-personal
	ssh -t -A -p $(service_ssh_port) $(ssh_remote_user)@$(ssh_vip) || true

cat:
	@ssh -p $(service_ssh_port) $(ssh_remote_user)@$(ssh_vip) tee $(FILE)

enter:
	docker exec -ti -u $(ssh_remote_user) $(service) bash -il -c 'cd; exec bash -il'

enter-service:
	docker exec -ti -u $(ssh_remote_user) $(service) bash -il -c 'cd; exec bash -il'

home:
	$(make) reset-base daemon home-setup home-deploy
	$(make) image-update
	docker tag $(registry)/$(image) $(registry)/$(image)0

home-setup:
	echo "Host *" | $(service_ssh_exec) -- tee .ssh/config
	echo "StrictHostKeyChecking no" | $(service_ssh_exec) -- tee -a .ssh/config

home-deploy:
	script/deploy $(service_ssh_exec)

docker_default = docker-block

BLOCK_KIT ?= block

docker:
	$(make) docker-is-$(BLOCK_KIT)

docker-is-block:
	$(make) $(docker_default)

docker-is-kit:
	source ../block/script/profile $(PWD) && $(make) $(docker_default)

docker-block:
	$(make) reset daemon block-setup block-deploy

block-setup:
	jq -n --arg block $(block) --arg org $(org) --arg version $(version) '{ require: [ "\($$org)/\($$block)@\($$version)" ] }' | $(service_ssh_exec) -- tee Blockfile.json.site

block-deploy:
	$(make) image-update

after_block ?= minimize

minimize:
	$(service_ssh_exec) -- rm -rf work/pkgsrc/vendor/pkgsrc

image-update:
	$(make) block-update $(after_block) commit
	$(make) build
	$(make) clean

block-update:
	$(service_ssh_exec) -- git fetch
	$(service_ssh_exec) -- git reset --hard origin/master
	$(service_ssh_exec) -- cd work/$(block) 2>/dev/null \&\& git checkout $(shell git symbolic-ref HEAD | cut -d/ -f3) || $(service_ssh_exec) -- cd work/$(block) \&\& git checkout $(shell git symbolic-ref HEAD | cut -d/ -f3)
	$(service_ssh_exec) -- block clone
	if test -z "$(cache)"; then $(service_ssh_exec) -- home disable cache; fi
	$(service_ssh_exec) -- block bootstrap
	$(service_ssh_exec) -- make cache
	$(service_ssh_exec) -- rm -f service/$(home)
	$(service_ssh_exec) -- block compile service
	if test -x script/server; then $(service_ssh_exec) -- block compile service $(block); fi
	if test -x script/server; then $(service_ssh_exec) -- ln -nfs ../sv/$(block) service/; fi
	cat Blockfile.json | jq -r '.run//{sshd:{}} | keys[]' | runmany '$(service_ssh_exec) -- block compile service $$1'
	cat Blockfile.json | jq -r '.run//{sshd:{}} | keys[]' | runmany '$(service_ssh_exec) -- ln -nfs ../sv/$$1 service/'
	if test -z "$(cache)"; then $(service_ssh_exec) -- home enable cache; fi
	$(service_ssh_exec) -- rm -f .gitconfig

prune:
	docker ps -a | grep -v ' Up ' | tail -n +2 | awk '{print $$1}' | gxargs -r -n 1 bash -c 'docker rm -f $$1 2>/dev/null || true' ''
	docker images --filter "dangling=true" -q --no-trunc | gxargs -r docker rmi

clean:
	docker rm -f $(service) 2>/dev/null || true

stop:
	@docker exec $(service) sv stop ./service/$(STOP)

start:
	@docker exec $(service) sv start ./service/$(START)

status:
	@docker exec $(service) sv status ./service/$(STATUS)

ps:
	@$(docker_compose) ps

SERIAL = $(shell cat .serial)

.serial:
	@echo 1 > .serial

bump: .serial
	@echo $(SERIAL) + 1 | bc > .serial.tmp
	mv .serial.tmp .serial

reset-time:
	docker run -it --rm --privileged --pid=host debian nsenter -t 1 -m -u -n -i date -u $(shell date -u +%m%d%H%M%Y)

../$(REBUILD):
	git clone git@github.com:imma/$(REBUILD) ../$(REBUILD)
	
rebuild: ../$(REBUILD)
	@figlet $(REBUILD) 2>/dev/null || true
	@touch .$(REBUILD).building
	cd ../$(REBUILD) && $(extra) make docker
	@rm -f .$(REBUILD).building

rebuild-all:
	cat compose.json | jq -r '.services | keys[]' | grep -v ubuntu | runmany '$(make) rebuild $$1 || true'

local:
	docker images | grep $(hub)/block | awk '{print $$2}' | runmany 'docker tag $(hub)/block:$$1 $(registry)/block:$$1 && docker rmi $(hub)/block:$$1'

download:
	cat compose.json | jq -r '.services | keys[]' | runmany 'docker pull $(hub)/block:$$1'

upload:
	cat compose.json | jq -r '.services | keys[]' | runmany 'docker tag {$(registry),$(hub)}/block:$$1; docker push $(hub)/block:$$1'


